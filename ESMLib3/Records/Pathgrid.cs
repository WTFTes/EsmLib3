using EsmLib3.Exceptions;
using EsmLib3.RefIds;

namespace EsmLib3.Records;

public class Pathgrid : AbstractRecord
{
    public class DATAstruct
    {
        public int mX { get; set; } // Grid location, matches cell for exterior cells

        public int mY { get; set; }

        public short mGranularity { get; set; } // Granularity with which the graph was autogenerated
        
        public ushort mPoints { get; set; } // Number of path points.
    }

    public class Point // path grid point
    {
        public int mX { get; set; } // Location of point

        public int mY { get; set; }

        public int mZ { get; set; }

        public byte mAutogenerated { get; set; } // autogenerated vs. user coloring flag?
        
        public byte mConnectionNum { get; set; } // number of connections for this point
        
        public short mUnknown { get; set; }
    }

    public override RecordName Name => RecordName.PGRD;

    public RefId mCell { get; set; }

    public DATAstruct mData { get; set; } = new();
    
    public List<Point> mPoints { get; set; } = new();
    
    public List<uint> mRawConnections { get; set; } = new();
    
    public override void Load(EsmReader reader, out bool isDeleted)
    {
        isDeleted = false;

        mPoints.Clear();
        mRawConnections.Clear();

        var hasData = false;
        while (reader.HasMoreSubs)
        {
            reader.GetSubName();
            switch (reader.retSubName())
            {
                case RecordName.NAME:
                    mCell = reader.getRefId();
                    break;
                case RecordName.DATA:
                    reader.getHT(() =>
                    {
                        mData.mX = reader.BinaryReader.ReadInt32();
                        mData.mY = reader.BinaryReader.ReadInt32();
                        mData.mGranularity = reader.BinaryReader.ReadInt16();
                        mData.mPoints = reader.BinaryReader.ReadUInt16();
                    });
                    hasData = true;
                    break;
                case RecordName.PGRP:
                {
                    reader.getSubHeader();
                    var size = reader.GetSubSize();
                    // Check that the sizes match up. Size = 16 * path points
                    if (size != 16 * mData.mPoints)
                        throw new Exception("Path point subrecord size mismatch");

                    for (var i = 0; i < mData.mPoints; ++i)
                    {
                        Point p = new();
                        p.mX = reader.BinaryReader.ReadInt32();
                        p.mY = reader.BinaryReader.ReadInt32();
                        p.mZ = reader.BinaryReader.ReadInt32();
                        p.mAutogenerated = reader.BinaryReader.ReadByte();
                        p.mConnectionNum = reader.BinaryReader.ReadByte();
                        p.mUnknown = reader.BinaryReader.ReadInt16();

                        mPoints.Add(p);
                    }

                    break;
                }
                case RecordName.PGRC:
                {
                    reader.getSubHeader();
                    var size = reader.GetSubSize();
                    if (size % 4 != 0)
                        throw new Exception("PGRC size not a multiple of 4");

                    var rawConnNum = size / 4;
                    for (var i = 0; i < rawConnNum; ++i)
                        mRawConnections.Add(reader.BinaryReader.ReadUInt32());
                    break;
                }
                case RecordName.DELE:
                    reader.skipHSub();
                    isDeleted = true;
                    break;
                default:
                    throw new UnknownSubrecordException(reader.retSubName());
            }
        }
        
        if (!hasData)
            throw new MissingSubrecordException(RecordName.DATA);
    }

    public override void Save(EsmWriter writer, bool isDeleted)
    {
        writer.writeHNCRefId(RecordName.NAME, mCell);
        writer.writeHNT(RecordName.DATA, () =>
        {
            writer.Write(mData.mX);
            writer.Write(mData.mY);
            writer.Write(mData.mGranularity);
            writer.Write(mData.mPoints);
        });

        if (isDeleted)
        {
            writer.writeDeleted();
            return;
        }

        if (mPoints.Count > 0)
        {
            writer.writeHNT(RecordName.PGRP, () =>
            {
                foreach (var point in mPoints)
                {
                    writer.Write(point.mX);
                    writer.Write(point.mY);
                    writer.Write(point.mZ);
                    writer.Write(point.mConnectionNum);
                    writer.Write(point.mAutogenerated);
                    writer.Write(point.mUnknown);
                }
            });
        }

        if (mRawConnections.Count > 0)
        {
            writer.writeHNT(RecordName.PGRC, () =>
            {
                foreach (var rawConnection in mRawConnections)
                    writer.Write(rawConnection);
            });
        }
    }
}