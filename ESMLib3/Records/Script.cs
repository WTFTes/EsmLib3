using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Text;
using EsmLib3.Enums;
using EsmLib3.Exceptions;
using EsmLib3.RefIds;

namespace EsmLib3.Records;

public class Script : AbstractRecord
{
    public class SCHDstruct
    {
        /// Data from script-precompling in the editor.
        /// \warning Do not use them. OpenCS currently does not precompile scripts.
        public uint mNumShorts { get; set; }

        public uint mNumLongs { get; set; }
        
        public uint mNumFloats { get; set; }
        
        public uint mScriptDataSize { get; set; }
        
        public uint mStringTableSize { get; set; }
    }

    public override RecordName Name => RecordName.SCPT;

    public RefId mId { get; set; }

    public RecordFlag mRecordFlags { get; set; }

    public SCHDstruct mData { get; set; } = new();

    /// Variable names generated by script-precompiling in the editor.
    /// \warning Do not use this field. OpenCS currently does not precompile scripts.
    public List<string> mVarNames { get; set; } = new();
    
    /// Bytecode generated from script-precompiling in the editor.
    /// \warning Do not use this field. OpenCS currently does not precompile scripts.
    public byte[] mScriptData { get; set; }
    
    public string mScriptText { get; set; }
    
    // save game data
    public List<short> mSaveGameShorts { get; set; } = new();
    public List<int> mSaveGameLongs { get; set; } = new();
    public List<float> mSavegameFloats { get; set; } = new();

    public int mRefNum { get; set; } = -1;
    
    public bool mRunning { get; set; }
    
    public override void Load(EsmReader reader, out bool isDeleted)
    {
        isDeleted = false;
        mRecordFlags = reader.getRecordFlags();

        var numSaveGameShorts = 0;
        var numSaveGameLongs = 0;
        var numSaveGameFloats = 0;
        
        mData = new();
        var hasHeader = false;
        while (reader.HasMoreSubs)
        {
            reader.GetSubName();
            switch (reader.retSubName())
            {
                case RecordName.SCHD:
                    reader.getSubHeader();
                    mId = reader.getMaybeFixedRefIdSize(32);
                    mData.mNumShorts = reader.BinaryReader.ReadUInt32();
                    mData.mNumLongs = reader.BinaryReader.ReadUInt32();
                    mData.mNumFloats = reader.BinaryReader.ReadUInt32();
                    mData.mScriptDataSize = reader.BinaryReader.ReadUInt32();
                    mData.mStringTableSize = reader.BinaryReader.ReadUInt32();

                    hasHeader = true;
                    break;
                case RecordName.SLCS:
                    // save game local script data
                    reader.getHT(() =>
                    {
                        numSaveGameShorts = reader.BinaryReader.ReadInt32();
                        numSaveGameLongs = reader.BinaryReader.ReadInt32();
                        numSaveGameFloats = reader.BinaryReader.ReadInt32();
                    });
                    break;
                case RecordName.SLSD:
                    reader.getHT(() =>
                    {
                        for (var i = 0; i< numSaveGameShorts;++i)
                            mSaveGameShorts.Add(reader.BinaryReader.ReadInt16());
                    });
                    break;
                case RecordName.SLLD:
                    reader.getHT(() =>
                    {
                        for (var i = 0; i< numSaveGameLongs;++i)
                            mSaveGameLongs.Add(reader.BinaryReader.ReadInt32());
                    });
                    break;
                case RecordName.SLFD:
                    reader.getHT(() =>
                    {
                        for (var i = 0; i < numSaveGameFloats; ++i)
                            mSavegameFloats.Add(reader.BinaryReader.ReadInt32());
                    });
                    break;
                case RecordName.SCVR:
                    // list of local variables
                    loadSCVR(reader);
                    break;
                case RecordName.SCDT:
                    // compiled script
                    reader.getSubHeader();
                    var subSize = reader.GetSubSize();

                    if (subSize != mData.mScriptDataSize)
                        Debug.WriteLine(
                            "Script data size defined in SCHD subrecord does not match size of SCDT subrecord");

                    mScriptData = reader.BinaryReader.ReadBytes((int)subSize);
                    break;
                case RecordName.SCTX:
                    mScriptText = reader.getHString();
                    break;
                case RecordName.RNAM:
                    mRunning = true;
                    reader.getHT(() => mRefNum = reader.BinaryReader.ReadInt32());
                    break;
                case RecordName.DELE:
                    reader.skipHSub();
                    isDeleted = true;
                    break;
                default:
                    throw new UnknownSubrecordException(reader.retSubName());
            }
        }
        
        if (!hasHeader)
            throw new MissingSubrecordException(RecordName.SCHD);
    }

    private void loadSCVR(EsmReader reader)
    {
        var s = mData.mStringTableSize;
        
        // not using getHExact, vanilla doesn't seem to mind unused bytes at the end
        reader.getSubHeader();
        var left = reader.GetSubSize();
        if (left < s)
            throw new Exception("SCVR string list is smaller than specified");

        var tmp = reader.BinaryReader.ReadBytes((int)s).ToList();
        if (left > s)
            reader.skip(left - s); // skip the leftover junk
        
        // Set up the list of variable names
        mVarNames.Clear();
        CollectionsMarshal.SetCount(mVarNames, (int)(mData.mNumShorts+mData.mNumLongs+mData.mNumFloats));

        // The tmp buffer is a null-byte separated string list, we
        // just have to pick out one string at a time.
        if (tmp.Count == 0)
        {
            if (mVarNames.Count > 0)
                throw new Exception("SCVR with no variable names");

            return;
        }
        
        // Support '\r' terminated strings like vanilla.  See Bug #1324.
        for (var i = 0; i < tmp.Count; ++i)
            if (tmp[i] == '\r')
                tmp[i] = 0;

        if (tmp[^1] != 0)
            tmp.Add(0);

        var str = 0;
        for (var i = 0; i < mVarNames.Count; ++i)
        {
            mVarNames[i] = Encoding.ASCII.GetString(tmp.Skip(str).TakeWhile(b => b != 0).ToArray());
            str += mVarNames[i].Length + 1;
            if (str >= tmp.Count)
            {
                if (str > tmp.Count)
                {
                    Debug.WriteLine("String table overflow");
                }

                CollectionsMarshal.SetCount(mVarNames, i + 1);
                break;
            }
        }
    }

    public override void Save(EsmWriter writer, bool isDeleted)
    {
        writer.writeHNT(RecordName.SCHD, () =>
        {
            writer.writeMaybeFixedSizeRefId(mId, 32);
            writer.Write(mData.mNumShorts);
            writer.Write(mData.mNumLongs);
            writer.Write(mData.mNumFloats);
            writer.Write(mData.mScriptDataSize);
            writer.Write(mData.mStringTableSize);
        });

        if (isDeleted)
        {
            writer.writeDeleted();
            return;
        }

        if (mVarNames.Count > 0)
        {
            writer.writeHNT(RecordName.SCVR, () =>
            {
                foreach (var name in mVarNames)
                    writer.writeHCString(name);
            });
        }

        writer.writeHNT(RecordName.SCDT, mScriptData);
        
        writer.writeHNOString(RecordName.SCTX, mScriptText);
    }
}